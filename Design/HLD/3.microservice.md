# Monolithic vs Microservices Architecture - Detailed Notes

## Overview
This is the third video in the High Level Design series, covering the differences between monolithic and microservices architectures, along with important microservices patterns.

---

## Architecture Types

### 1. Monolithic Architecture

**Definition**: A single application where all functionalities are bundled together into one codebase.

**Characteristics**:
- Also referred to as "legacy applications" in modern contexts
- All backend functionalities in ONE application
- Single deployment unit
- Shared database
- Tightly coupled components

**Example - Online Store**:
```
Single Application Contains:
├── Order Generation
├── Product Inventory Management
├── Login Management
├── Billing
├── Payment Processing
└── All Backend Functionalities
```

---

## Disadvantages of Monolithic Architecture

### 1. **Overloaded IDE**
- Application becomes extremely large (sometimes gigabytes)
- IDEs struggle to load the entire codebase
- Takes excessive time to open and work with
- Developer productivity severely impacted

### 2. **Scaling is Very Hard**
- Cannot scale individual components
- Must scale the ENTIRE application even if only one feature needs scaling

**Example**:
```
Scenario: High traffic on Order API
Required: Scale only ordering functionality
Reality: Must deploy entire 10GB application on new server
Cost: Extremely expensive and inefficient
```

### 3. **Tightly Coupled Components**
- Changing one line can impact multiple domains
- All code is interconnected
- One bug fix might break other functionalities

### 4. **Slow Development Cycle**
- **Regression Testing**: Test entire application for any change
- **Deployment**: Deploy entire application for one-line fix
- **CI/CD**: Extremely slow continuous integration jobs
- **Time-consuming**: All operations take excessive time

### 5. **Difficult Debugging**
- Hard to isolate issues in large codebase
- Impact analysis is complex
- Changes have unpredictable ripple effects

---

## Microservices Architecture

**Definition**: Breaking down a large application into smaller, independent services that communicate with each other.

### Architecture Example:
```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Product   │  │    Order    │  │   Billing   │
│   Service   │  │ Management  │  │   Service   │
└─────────────┘  └─────────────┘  └─────────────┘

┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Payment   │  │   Account   │  │    Login    │
│   Service   │  │ Management  │  │   Service   │
└─────────────┘  └─────────────┘  └─────────────┘
```

---

## Advantages of Microservices

### 1. **Easy Component Management**
- Debug only the affected service
- Fix and deploy individual services
- Smaller, manageable codebases

### 2. **Excellent Scalability**
- Scale only what's needed
- Cost-effective (pocket-friendly)
- Independent scaling of services

**Example**:
```
High traffic on Orders → Scale ONLY Order Service ✅
Low traffic on Login → Keep Login Service as is ✅
```

### 3. **Faster Development Cycle**
- Quick regression testing (service-specific)
- Rapid deployment of individual services
- Efficient CI/CD pipelines

### 4. **Loosely Coupled**
- Services can be modified independently
- Minimal impact on other services
- Technology diversity possible

---

## Disadvantages of Microservices

### 1. **Proper Decomposition Required**
- Must be divided correctly into loosely coupled services
- Poor decomposition leads to tightly coupled services
- Requires deep understanding of business domain

**Problem with Poor Decomposition**:
```
Service1 → depends on → Service2
Service2 → depends on → Service3
Service3 → depends on → Service1
Result: Circular dependencies, high latency
```

### 2. **Latency Issues**
- Inter-service communication adds latency
- Network calls between services
- Can increase from 2ms (monolithic) to 10ms (microservices)

### 3. **Complex Monitoring & Debugging**
- Service dependencies can break
- Chain reactions when one service fails
- Difficult to identify root cause

**Example**:
```
S3 deploys new code → Changes response format
S2 uses S3 → S2 breaks
S1 uses S2 → S1 breaks
Result: Cascading failures
```

### 4. **Transaction Management Complexity**
**Monolithic**:
- Single database
- Simple transaction with ACID properties
- Easy rollback

**Microservices**:
```
Service1 → DB1 (Success) ✅
Service2 → DB2 (Fail) ❌
Problem: How to rollback DB1?
Solution Needed: Distributed transaction management
```

---

## Microservices Design Patterns

### Phases of Microservices Design

```
1. DECOMPOSITION
   ↓
2. DATABASE
   ↓
3. COMMUNICATION
   ↓
4. INTEGRATION & GOVERNANCE
   ↓
5. OBSERVABILITY
```

---

## 1. Decomposition Patterns

### Purpose
Define how to break down a monolithic application into smaller microservices.

### A. Decompose by Business Capability

**Approach**: Create services based on business functions

**Example - Online Order Application**:
```
Business Capabilities → Microservices
├── Order Management → Order Service
├── Product Management → Product Service
├── Account Management → Account Service
├── Login → Login Service
├── Billing → Billing Service
└── Payment → Payment Service
```

**Requirements**:
- Good knowledge of business functionality
- Clear understanding of business capabilities
- Each service handles one business function

**Key Point**:
- "Micro" is relative - no fixed definition
- Size depends on project context
- Order Management might be huge but still one microservice in this context

### B. Decompose by Subdomain (Domain-Driven Design - DDD)

**Approach**: One domain can have multiple microservices

**Example 1 - Order Domain**:
```
Order Management Domain
├── Order Placing Service
├── Order Tracking Service
└── Order History Service
```

**Example 2 - Payment Domain**:
```
Payment Domain
├── Forward Payment Service (User pays)
└── Reverse Payment Service (Refunds)
```

**Key Difference from Business Capability**:
- Business Capability: One functionality = One service
- Subdomain: One domain = Multiple related services

---

## 2. Database Patterns

### Options:
1. **Database per Service**
    - Each service has its own database
    - Complete data isolation
    - Independent scaling

2. **Shared Database**
    - Common database for all services
    - Easier transaction management
    - Risk of tight coupling

---

## 3. Communication Patterns

### Methods:
- **API Communication** (REST, gRPC)
- **Event-Based Communication** (Message queues)
- **Minimal Direct Communication**

---

## 4. Integration Patterns

### Common Patterns:
- **API Gateway**: Single entry point for clients
- **Service Mesh**: Handle service-to-service communication
- **Backend for Frontend (BFF)**: Separate backends for different UIs

---

## Key Interview Points

### Common Question: "Advantages and Disadvantages of Microservices"

**Advantages**:
1. Independent deployment
2. Technology diversity
3. Fault isolation
4. Scalability
5. Small, manageable codebases

**Disadvantages**:
1. Distributed system complexity
2. Network latency
3. Data consistency challenges
4. Operational overhead
5. Testing complexity

### Decision Factors: Monolithic vs Microservices

**Choose Monolithic when**:
- Small team
- Simple application
- Proof of concept
- Limited resources

**Choose Microservices when**:
- Large, complex application
- Multiple teams
- Different scaling requirements
- Need for technology diversity
- High availability requirements

---

## Important Concepts

### Loosely Coupled vs Tightly Coupled

**Loosely Coupled** (Goal):
- Services can be changed independently
- Minimal dependencies
- Can scale independently
- Technology agnostic

**Tightly Coupled** (Avoid):
- Changes affect multiple services
- Circular dependencies
- Must scale together
- Shared databases/code

---

## Best Practices

1. **Start with proper decomposition** - Get it right the first time
2. **Maintain loose coupling** - Avoid circular dependencies
3. **Design for failure** - Services will fail; plan for it
4. **Implement proper monitoring** - Track service health and dependencies
5. **Use patterns appropriately** - Not all patterns fit all scenarios
6. **Consider latency** - Account for network communication overhead
7. **Plan transaction management** - Distributed transactions are complex

---

## Key Takeaways

1. ✅ Microservices solve monolithic problems but introduce new complexities
2. ✅ Proper decomposition is critical for success
3. ✅ "Micro" is contextual - no fixed size definition
4. ✅ Multiple patterns exist for different aspects of microservices
5. ✅ Transaction management is complex in distributed systems
6. ✅ Monitoring and debugging become more challenging
7. ✅ Choose architecture based on specific requirements, not trends

---

## Common Misconceptions

❌ "Microservices are always better than monolithic"
- **Reality**: Depends on use case and team capabilities

❌ "Each microservice should be tiny"
- **Reality**: Size is relative to business context

❌ "Microservices eliminate all coupling"
- **Reality**: Some coupling is inevitable; aim for loose coupling

❌ "All modern applications should use microservices"
- **Reality**: Many successful applications still use monolithic architecture