# Microservices Design Patterns - Part 2 - Detailed Notes

## Overview
This is Part 2 of the Microservices Design Patterns series, building upon the decomposition patterns covered in Part 1. This session covers three critical patterns essential for microservices architecture.

---

## Three Key Patterns Covered

1. **Strangler Pattern** - Migration strategy
2. **Saga Pattern** - Distributed transaction management
3. **CQRS (Command Query Responsibility Segregation)** - Query optimization

**Note**: Strangler and Saga patterns are extremely important for interviews and practical implementation.

---

## 1. Strangler Pattern

### Purpose
Used for **refactoring monolithic applications to microservices** gradually and safely.

### When to Use
- When migrating from existing monolithic to microservices
- Need to maintain system availability during migration
- Want to minimize risk during transformation

### How It Works

```
                    Controller
                        ↓
        ┌───────────────┴───────────────┐
        ↓                               ↓
   Microservices                   Monolithic
   (New System)                   (Old System)
```

### Implementation Strategy

1. **Traffic Controller Setup**
    - Place a controller between incoming API traffic and services
    - Controller manages traffic distribution percentage

2. **Gradual Migration Process**
   ```
   Step 1: 10% traffic → Microservices, 90% → Monolithic
   Step 2: 20% traffic → Microservices, 80% → Monolithic
   Step 3: 50% traffic → Microservices, 50% → Monolithic
   Step 4: 100% traffic → Microservices, 0% → Monolithic
   Step 5: Decommission Monolithic
   ```

3. **Rollback Capability**
    - If microservices fail, immediately redirect 100% traffic to monolithic
    - Fix issues in microservices
    - Resume gradual migration

### Key Benefits
- **Risk Mitigation**: Can rollback instantly if issues arise
- **Gradual Transition**: Build confidence with incremental changes
- **Zero Downtime**: System remains operational throughout migration
- **Testing in Production**: Real traffic validates new services

### Real-World Example
```
Initial State: Monolithic handling 1000 transactions/sec
↓
Build Order Service → Route 10% order traffic
↓
Build Payment Service → Route 20% payment traffic
↓
Continue building services...
↓
Final State: All traffic to microservices, monolithic deleted
```

---

## 2. Database Management in Microservices

### Two Approaches

#### A. Shared Database

```
    S1      S2      S3
     ↓       ↓       ↓
    ┌─────────────────┐
    │  Common DB      │
    │  (Tables 1-10)  │
    └─────────────────┘
```

**Advantages**:
- Easy JOIN operations across tables
- Simple transaction management (ACID properties)
- Single point of data consistency

**Disadvantages**:
- **Cannot scale individually** - Must scale entire DB even for one service's needs
- **Team dependencies** - Changes require coordination across teams
- **Technology lock-in** - All services must use same DB technology
- **Tight coupling** - Services become interdependent

#### B. Database Per Service (Recommended)

```
    S1          S2          S3
     ↓           ↓           ↓
   DB1         DB2         DB3
  (SQL)     (MongoDB)   (Postgres)
```

**Advantages**:
- **Independent scaling** - Scale only what's needed
- **Technology diversity** - Each service chooses best DB for its needs
- **Team autonomy** - Teams can modify their DB independently
- **Loose coupling** - Services remain independent

**Disadvantages**:
- Complex distributed transactions
- Difficult JOIN operations across services
- Data consistency challenges

**Important Rule**:
> ⚠️ **No service can directly query another service's database**
> - Service 2 cannot query DB3 directly
> - Must request data via Service 3's API

---

## 3. Saga Pattern

### Problem It Solves
Managing **distributed transactions** across multiple microservices with independent databases.

### What is Saga?
**Definition**: A sequence of local transactions where each transaction updates its database and publishes an event.

### Transaction Scenario Example

```
Order Placement Transaction:
1. Update Order DB (Success) ✅
2. Update Inventory DB (Success) ✅
3. Update Payment DB (Failed) ❌

Problem: How to rollback Order and Inventory updates?
Solution: Saga Pattern
```

### Two Implementation Types

#### A. Choreography-Based Saga

```
S1 → Event → S2 → Event → S3
↑                          ↓
←── Compensation Event ────←
```

**Process Flow**:
1. Service 1 completes local transaction → Publishes "Order Created" event
2. Service 2 listens → Updates inventory → Publishes "Inventory Updated" event
3. Service 3 listens → Payment fails → Publishes "Payment Failed" event
4. Service 2 listens to failure → Rolls back inventory → Publishes compensation event
5. Service 1 listens → Rolls back order

**Advantages**:
- Simple implementation
- No central coordinator
- Services remain autonomous

**Disadvantages**:
- Risk of cyclic dependencies
- Complex event chains
- Difficult to track overall transaction state

#### B. Orchestration-Based Saga

```
         Orchestrator
        ↙     ↓     ↘
      S1      S2      S3
```

**Process Flow**:
1. Orchestrator calls S1 → Gets response
2. Based on S1 success → Orchestrator calls S2
3. Based on S2 success → Orchestrator calls S3
4. If S3 fails → Orchestrator instructs S2 to rollback
5. Orchestrator instructs S1 to rollback

**Advantages**:
- Centralized transaction logic
- No cyclic dependencies
- Easier to monitor and debug
- Clear transaction flow

**Disadvantages**:
- Single point of failure (orchestrator)
- Additional component to maintain

---

## Interview Example: Payment Transaction

### Scenario
Person A needs to pay Person B ₹10

### Microservices Architecture
```
Balance Service          Payment Service
- Manages user balance   - Records transactions
- Current: ₹100         - Stores payment history
```

### Transaction Flow & Problem
```
1. Check balance (₹100 available) ✅
2. Deduct ₹10 from balance (₹90 remaining) ✅
3. Record payment transaction ❌ FAILED

Problem: Balance deducted but no payment record!
```

### Solution Using Saga
```
1. Payment Service publishes "Payment Failed" event
2. Balance Service listens to failure event
3. Balance Service performs compensation transaction
4. Adds ₹10 back to balance (₹100 restored)
```

**Key Interview Points**:
- Identify the distributed transaction problem
- Propose Saga pattern as solution
- Explain compensation transactions
- Choose between choreography vs orchestration

---

## 4. CQRS (Command Query Responsibility Segregation)

### Problem It Solves
How to perform JOIN operations across different microservice databases.

### Concept
**Separate databases for write operations (Commands) and read operations (Queries)**

### Architecture

```
Write Operations (CUD)           Read Operations (Select)
        ↓                                ↓
  Service DBs                      Read View DB
   - Order DB                    (Combined Data from
   - Inventory DB                 all service DBs)
```

### Components

#### Commands (Write)
- **CREATE** - Add new records
- **UPDATE** - Modify existing records
- **DELETE** - Remove records

#### Query (Read)
- **SELECT** - Read operations
- Performed on separate read-optimized database

### Implementation

```
Order Service → Order DB
     ↓ (Event)
     ↓
Read View DB (Contains joined data from all services)
     ↑
     ↑ (Event)
Inventory Service → Inventory DB
```

### Synchronization Methods

1. **Event-Based**
    - Services publish events on CUD operations
    - Read DB listens and updates itself

2. **Database Triggers**
    - Automatic triggers on CUD operations
    - Updates propagated to read DB

3. **Stored Procedures**
    - Procedures run on CUD operations
    - Synchronize changes to read DB

### Benefits
- Enables complex queries across services
- Optimized read performance
- Maintains service independence
- Scalable read operations

---

## Key Takeaways

### Most Important Patterns
1. **Strangler Pattern** - Essential for migration strategies
2. **Saga Pattern** - Critical for distributed transactions
3. **CQRS** - Important for complex queries

### Interview Preparation
- ✅ Understand Saga pattern thoroughly (very common question)
- ✅ Know when to use choreography vs orchestration
- ✅ Be ready to solve payment/order scenarios
- ✅ Understand database per service trade-offs

### Best Practices
1. **Migration**: Always use Strangler pattern for monolithic to microservices
2. **Transactions**: Implement Saga for distributed transactions
3. **Queries**: Consider CQRS when JOIN operations needed
4. **Database**: Prefer database per service for true microservices benefits

### Common Interview Questions
1. "How would you handle distributed transactions in microservices?"
    - Answer: Saga pattern with compensation transactions

2. "How to migrate from monolithic to microservices?"
    - Answer: Strangler pattern with gradual traffic migration

3. "How to perform queries across multiple microservice databases?"
    - Answer: CQRS pattern with read-optimized views

---

## Design Considerations

### When to Use Each Pattern

| Pattern | Use When |
|---------|----------|
| **Strangler** | Migrating existing monolithic systems |
| **Saga** | Need distributed transactions with rollback capability |
| **CQRS** | Complex queries across multiple service boundaries |

### Anti-Patterns to Avoid
❌ Direct database access across services
❌ Shared database for all microservices
❌ Big-bang migration (all at once)
❌ Ignoring compensation transactions in Saga

---

## Practical Implementation Tips

1. **Start Small**: Begin with one service using Strangler pattern
2. **Monitor Everything**: Track success/failure rates during migration
3. **Plan Rollbacks**: Always have compensation logic in Saga
4. **Document Events**: Maintain clear event schemas
5. **Test Failure Scenarios**: Ensure Saga handles all failure cases

---

## Summary
These three patterns form the backbone of successful microservices implementations:
- **Strangler** enables safe migration
- **Saga** ensures data consistency
- **CQRS** optimizes query performance

Master these patterns for both interview success and real-world microservices development.